02. 리팩터링 원칙

리팩터링의 정의

1. 리팩터링[명사] : 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법 (ex, 함수 추출하기, 조건부 로직 다형성으로 바꾸기)
2. 리팩터링[동사] : 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

사람이 코드를 정리하는 작업 ≠ 리팩터링

특정한 방식에 따라 코드를 정리하는 것 == 리팩터링

한 번에 바꿀 수 있는 작업을 수많은 단계로 잘게 나눠서 작업하는 모습을 처음 접하면 리팩터링하는 것이 비효율적이라 생각할 수 있지만 잘게 나눔으로써 
단계들이 체계적으로 구성되어 있고 디버깅하는데 시간을 뺏기지 않기 때문에 오히려 작업을 더 빨리 처리할 수 있다.

리팩터링과 성능 최적화
공통점 : 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다
차이점 : 리팩터링은 코드를 이해하고 수정하기 쉽게 만드는 것으로 프로그램 성능이 좋아질 수도, 나빠질 수도 있다.
         성능 최적화는 오로지 속도 개선에만 신경쓴다. 목표 성능에 반드시 도달해야 한다면 코드는 다루기에 더 어렵게 바뀔 수 있다.(서로 목표가 다름)
         

두 개의 모자

소프트웨어를 개발할 때 목적이 '기능 추가'이냐 '리팩터링'이냐를 명확히 구분해 작업하는 것
켄트 벡이 이를 두 개의 모자에 비유했다.


리팩터링하는 이유

1. 리팩터링하면 소프트웨어 설계가 좋아진다
   리팩터링하지 않으면 소프트웨어의 내부 설계(아키텍처)가 썩기 쉽다. 
   아키텍처를 충분히 이해 못한채 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. -> 코드만 보고 설계를 파악하기 어렵다.
   (ex. 중복 코드 발생으로 수정이 어려워짐)
2. 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
   기억할 필요가 있는 코드들의 목적이 잘 드러나게 리팩터링하여 이해를 돕는다.
3. 리팩터링하면 버그를 쉽게 찾을 수 있다.
   리팩터링하면 코드가 하는 일을 깊이 파악하게 되면서 버그들이 드러난다.
4. 리팩터링하면 프로그래밍 속도를 높일 수 있다.
   내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 모두 품질 향상에 직결된다.
   
   
언제 리팩터링해야 할까?

3의 법칙
 1. 처음엔 그냥 한다.
 2. 비슷한 일을 두 번째로 하게 되면 일단 계속 진행한다.
 3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

 - 준비를 위한 리팩터링 : 기능을 쉽게 추가하게 만들기
   리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.
   (중복된 코드를 '함수 매개변수화하기'를 적용하여 한 곳으로 합친다)
 - 이해를 위한 리팩터링 : 코드를 이해하기 쉽게 만들기
   코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지를 찾아본다.
   조건부 로직 구조, 함수 이름 등등
 - 쓰레기 줍기 리팩터링
   간단하게 수정할 수 있는 것은 즉시 수정하고, 시간이 좀 걸리는 일은 짧은 메모를 남긴 뒤 하던 일을 끝내고 나서 처리한다.
   리팩터링은 각각의 작은 단계가 코드를 깨드리지 않기 때문에 작업을 잘게 나누어 몇달에 걸쳐 진행해도 괜찮다.
 - 계획된 리팩터링과 수시로 하는 리팩터링
   계획된것보단 수시로 하는게 좋은데 그동안 리팩터링에 소홀했다면 계획하는것도 ㄱㅊ
 - 오래 걸리는 리팩터링
   라이브러리를 교체하는 작업 or 일부 코드를 다른 팀과 공유하기 위해 컴포넌트를 빼내는 작업 등과 같은 대규모 리팩터링
 - 코드 리뷰에 리팩터링 활용하기
   리팩터링은 코드리뷰의 결과를 더 구체적으로 도출하는데에 도움이된다. 개선안들을 제시하는 데서 그치지 않고 상당수를 즉시 구현해볼 수 있기 때문이다.
   코드 작성자와 함께 검토하며 리팩터링한다.
 - 리팩터링하지 말아야 할 때
   지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링하지 않는다
   (ex. 외부 API 다루듯 호출해서 쓰는코드)
   리팩터링하는 것보다 처음부터 새로 작성하는게 쉬울 때도 리팩터링하지 않는다.


리팩터링 시 고려할 문제

 - 새 기능 개발 속도 저하 : 리팩터링의 궁극적인 목적은 개발 속도를 높여서 더 적은 노력으로 더 많은 가치를 창출하는 것
 - 코드 소유권은 개인보다는 팀 단위가 좋다.
 - 브랜치 : 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다. 자주 통합되어야 리팩터링에 좋다.
 - 테스팅 : 성공/실패 여부를 판단하는 테스트 코드를 작성
 - 레거시 코드가 있다면 테스트 작성부터한다.
   테스트 코드가 없다면 그것은 레거시 코드이다.
 - 데이터베이스
 

리팩터링, 아키텍처, 애그니(YAGNI)

 - 변화를 예상하고, 유연하게 대응하려다 보면 장황해진다.
 - 그저 현재 파악한 요구사항만 멋지게 설계하고 해결하자.
 - 진행하면서 요구사항을 알게 된다면 그에 맞게 리팩터링하자.
 - 하지만 앞으로의 변경이 뻔히 보이고 그것이 리팩터링을 어렵게 만든다면, 그때 유연성 매커니즘을 추가한다.(애그니)
 - 선제적인 설계와 점진적 설계의 균형에서 후자에 더 무게를 둔 진화형 아키텍처
 - 설계에 관한 결정을 시간을 두고 반복해서 내린다.

리팩터링과 소프트웨어 개발 프로세스

 - 익스트림 프로그래밍이란, 지속적 통합(CI), 자가 테스트 코드, 리팩터링 등의 기법들을 묶은 프로세스다.
 - 자가 테스트 코드와 리팩터링을 묶어서 테스트 주도 개발(TDD)라 칭한다.
 - 리팩터링의 첫 번째 토대는 자가 테스트 코드다.
 - CI를 통해 팀원간의 코드가 계속 통합되어야 높은 효과가 있다.
 - 자가 테스트 코드 + CI + 리팩터링 => 애그니 가능
 - 자가 테스트 코드 + CI + 리팩터링 => 배포 주기를 짧게 가져갈 수 있도록 만들어준다.

리팩터링과 성능

 - 리팩터링을 하면 성능을 좋게 만들기 쉬워진다.
 - 추측만으로 성능에 대해 판단하지 마라.
 - 대부분은 프로그램은 극히 일부 구간에서 많은 시간을 소비한다. 때문에 코드 전체를 최적화한다면 효과는 거의 없고 코드만 덜 명료해질 뿐이다.
 - 의도적으로 성능 최적화에 돌입하기 전에는 성능에 신경쓰지 말고 코드를 다루기 쉽게 만드는데 집중해라.
