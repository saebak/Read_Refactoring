# 캡슐화

<b>모듈을 잘 분리하는 가장 중요한 기준은
각 모듈이 자신을 제외한 외부에 드러내지 않아야 할 비밀을 얼마나 잘 숨기느냐에 있다.</b>

<br/>

## 1. 레코드 캡슐화하기

 - 레코드는 연관된 여러 데이터를 직관적인 방식으로 묶을 수 있어서 각각 따로 취급할 때 보다 훨씬 의미있는 단위로 전달할수 있음
 - 레코드는 다양한 프로그래밍 작업에 유용하지만 필드를 명확히 알려주지 않는다는 단점이 있음(불분명함)
 - 레코드(해시)를 데이터 클래스로 전환하는 리팩터링
 
### 절차
 
 1. 레코드를 담을 변수를 캡슐화한다.<br/>(-> 레코드를 캡슐화하는 함수의 이름은 검색하기 쉽게 지어준다.)
 2. 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다.<br/>이 클래스에 원본 레코드를 반환하는 접근자도 정의하고, 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다.
 3. 테스트한다
 4. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.
 5. 레코드를 반환하는 예전함수를 사용하는 코드를 4번에서 만든 새 함수를 사용하도록 바꾼다.<br/> 필드에 접근할 때는 객체의 접근자를 사용한다. 적절한 접근자가 없다면 추가한다. 한 부분을 바꿀 때마다 테스트한다.
 6. 클래스에서 원본 데이터를 반환하는 접근자와 원본레코드를 반환하는 함수들을 제거한다.
 7. 테스트한다.
 8. 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용한다.

### before
  <pre> organization = {name: "Acme Gooseberries", country: "GB"}; </pre>

### after
<pre>
class Organization { 
  constructor(data) { 
    this._name = data.name; 
    this._country = data.country; 
  } 
  get name() {return this._name;} 
  set name(arg) {this._name = arg;} 
  get country() {return this._country;} 
  set country(arg) {this._country = arg;} 
}
</pre>
